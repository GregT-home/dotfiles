#!/bin/sh

# convert
#    shell script to convert CMU Makefiles into a form that ODE 3.1 pmake
#    can accept.  It is not meant to be a complete conversion tool, only
#    an automation of recognized manual procedures.

Usage='
	convert [-recurse] [-pattern pat] dirname [dirname...]

	dirname is the name of directory in which the Makefile(s) are
	to be converted.  The default makefile pattern is "Makefile".

	-recurse	indicates that all subdirectories beneath the
			specified directories are to be processed.

	-pattern pat	indicates that "pat" should be used as the file
			expression to be converted.

	If the original file is a symbolic link, it is renamed to have
	an extension of ".olnk", otherwise, it is renamed to have an extension
	of ".old".
'
nl='
'
tmpfile=/tmp/mkconv$$.list
sedfile=/tmp/mkconf$$.sed

do_recurse=n
file_pat="Makefile"

# Process any flags
while : true
do
    case $1 in
	-recurse|-r*)
	    do_recurse="y"
	    ;;
	-pattern|-p*)
	    shift
	    file_pat="$1"
	    ;;
	-*) echo 1>&2 "? Unrecognized flag: $1$nl$Usage"
	    exit 1
	    ;;
	""|*)  break
	    ;;
    esac
    shift
done

case $file_pat in
    "") echo 1>&2 "?No file pattern specified$nl$Usage"; exit 1 ;;
esac

#
# Check for no arguments
# If building, but no args, flag an error.
case $# in
    0) echo 1>&2 "?No argument specified$nl$Usage"; exit 1 ;;
esac

# enable cleanup
trap 'rm -f $tmpfile $sedfile; exit' 0 1 2 3 4 10 12

# Create the sed conversion file.  We create a temporary file so that
# this script can look prettier, technically we could stuff all this into
# a quoted string.  Pushing it into a file minimizes the quoting hassles.
# Adds a dot to includes that lack it, changes any inclusion of something that
# uses MAKEFILEPATH into an include of <${RULES_MK}>, and/or adds quotation
# marks to the include file name, if they are missing.
#
# The conversion of any files prefixed by ${MAKEFILEPATH}/ is predicated on the
# notion that only a single inclusion of ${RULES_MK} is needed these days and
# multiple inclusions of that file are no-ops.  Prior to the end of the
# project, an awk script should be written to remove all superfluous inclusions
# of ${RUILES_MK}.
cat > $sedfile <<- 'endSED'
	0s** Conversion #1:	convert 'include file' to '.include "file"' *
	0s**      or 'include ${MAKEFILEPATH}file' to '.include <file>' *
	/^\.*include/{
		s/^\.include/include/
		/MAKEFILEPATH/!{
		    /"/!{
			/</!{
			    s/^include[ 	][ 	]*\(.*\)/include "\1"/
			}
		    }
		}			
		/MAKEFILEPATH/{
		    s/^include[ 	].*/include <${RULES_MK}>/
		}
	}
	/^\.*include[ 	]/s/^\.*include[ 	][ 	]*/.include /
endSED

# There could, potentially, be a LOT of names, so we don't want to bank on
# them all fitting into a Unix command line.  Hence we will
# create a file containing all of the candidate makefile names
#
rm -f $tmpfile		# delete any previous version
for dir
do
    case $do_recurse in
	# recursive search: let find determine the files that match the pattern
	y) find $dir -name "$file_pat" -print >> $tmpfile ;;

	# local search: save the filename unless wildcard char doesn't expand
	# which indicates that no file name matched
	n) echo $dir/$file_pat | egrep -v '\*|\?' | fmt -1 >> $tmpfile ;;

	# should not happen
	*) echo 1>&2 "?INTERNAL ERROR.  do_recurse = $do_recurse"; exit 1 ;;
    esac
done

# None found? Let the caller know.
test -z $tmpfile &&
    {
    echo "No files matched $dirname/$file_pat"
    exit 0
    }

cat $tmpfile

# ** PROBLEM ** deroff is removing the "./" from the file names, which keeps
# us from having an easy time of determining whether the specified directory
# is writeable or not.  Need a substitute.

#
# At this point, we should have a file full of candidate Makefile names
#
while read file
do
    echo "Processing $file"

#    test -w $file ||
     true ||
	{
	echo "$file not found or is not writeable"
	continue
	}

    rm -f ${file}.new
    sed -f $sedfile $file > ${file}.new

    cmp ${file}.new ${file} > /dev/null 2>&1
    status=$?

    case $status in
	# files match, no conversion performed
	0)  echo "No changes made to $file"
	    rm -f ${file}.new
	    ;;

	# files don't match, rename the original
	1)  test -L ${file} && mv -f ${file} ${file}.olnk
	    test -f ${file} && mv -f ${file} ${file}.old
	    mv -f ${file}.new ${file}
	    ;;
	*)  echo 1>&2 "?Unknown return from cmp ${file}.new ${file}: $status"
	    rm -f ${file}.new
	    ;;	    
    esac
done < $tmpfile

