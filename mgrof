#!/usr/local/bin/perl
# -*-Fundamental-*-

#eval '(exit $?0)' && eval 'exec perl5 -S $0 ${1+"$@"}'
#  & eval 'exec perl5 -S $0 $argv:q'
#  if 0;
#  THE PRECEEDING STUFF EXECS perl5 via $PATH

use Carp;
use strict;
$| = 1;

my $Myname;
($Myname = $0) =~ s%^.*/%%;

my $Usage = <<LIT;
$Myname: usage: $Myname [-c] [-r 'n'] [-f] [-o 'options'] <user>
where
   -c shows the managament chain up from <user>
   -r shows the employees reporting 'n' levels down from <user>
   -f shows the full entry
   -o shows fields from this full entry
      'options' is a comma separated list and can be:
       login|unix       (UNIX login name)
       name|fullname    (full name)
       loc|room         (room number)
       phone|tele       (work number)
       title            (job title)
       level            (show as indentations)
       email            (work email)
       empno            (employee number)
       hire             (hire date)
       dept             (department name)
LIT


sub usage
{
  print STDERR $Usage;
  exit 1;
}


sub help
{
  print STDERR <<LIT;
$Usage

$Myname takes a login name, and prints information about the user's
manager or (with -c) management chain. By default, it will just print
the login name of the manager(s), but with -f will give more
information. You can specify an alternate set of information by
using the -o option.

The (-r) form takes the user name and tries to find the people
reporting to this user - where 'n' is the number of reporting levels
to drill down to.

You can also display more than just the users login name if you pass
in output parameters (-o).
LIT
  exit 1;
}

# option switch variables get defaults here...

my $Chain = 0;
my $Report = 0;
my $UseOptions = 0;
my $maxreport = 0;
my $displayoptions = "";
my $Full = 0;
my @Args;
my $Args;
#va#my $ORGCHART = "/x/eng/http/html/engineering/orgchart/Eng_Org_Chart.org.corp";
my $ORGCHART = "/x/eng/utils/share/Eng_Org_Chart.org.corp";
if (defined ($ENV{ORGCHART})) { $ORGCHART = $ENV{ORGCHART}; }

while ($#ARGV >= 0)
  {
    if    ($ARGV[0] eq "-c") { $Chain = 1;                 shift; next; }
    elsif ($ARGV[0] eq "-f") { $Full = 1; $UseOptions = 0; shift; next; }
    elsif ($ARGV[0] eq "-r") { $Report = 1;                shift; $maxreport = shift; next; }
    elsif ($ARGV[0] eq "-o") { $Full = 0; $UseOptions = 1; shift; $displayoptions = shift; next; }
    elsif ($ARGV[0] eq "-help")
      { &help; }
    elsif ($ARGV[0] =~ /^-/) { &usage; }
    if ($Args ne "") { $Args .= " "; }
    push(@Args, $ARGV[0]);
    shift;
  }

if ($#Args != 0) { &usage; }

my ($who) = $Args[0];


# new location of files
open(ORG, "<$ORGCHART")
  || die "can't open \"$ORGCHART \": $!";

my @management;
my @reports;

my $login;
my $found = 0;
my $reportlev = 0;
my $i = 1;

while (<ORG>)
  {
    if (/^(=+)([^:]+):([^:]+):/)
      {
	     my $levstr;
	     my $name;
	     my $lev;

        $levstr = $1; $name = $2; $login = $3;
        $lev = ($levstr =~ tr/=/=/) - 1;

        # Skip first level - the dummy root org...
        if ($lev == 0) { next; }
        if (! $found)
        {
           $management[$lev] = $_;
           splice(@management, $lev+1);
        }

        # IN reports mode - stop at 2 levels of management
        if ($Report && $reportlev > 0)
        {
           my $revdiff = $lev - $reportlev;
           if ($revdiff <= 0) { last; }
           elsif ($revdiff <= $maxreport) { $reports[$i] = $_; $i++}
        }

        # Check if we found the person...
        if ($login eq $who) 
        { 
           $found = 1; 
           $reportlev = $lev;
           if (! $Report) { last; } 
           else           { $reports[0] = $_; }
        }
      }
  }

if (! $found)
  { print "$who not found\n"; exit 1; }

if ($Chain)
  { foreach my $l (@management) { &show($l); } }

if ($Report)
  { 
    for (my $i=0; $i <= $#reports; $i++) 
    {
       if ($Chain && $i==0) { next; }
       else
       { &show($reports[$i]); }
    }
  }
elsif (! $Chain && ! $Report)
  { &show($management[$#management-1]); }

exit 0;

sub output
{
   my ($len, $value) = @_;

   my $fmt = "%-" . $len . "s";

   if ($value ne "")  
   { printf "$fmt ", $value; }  
   else { print "*" x $len; print " "; } 
}

sub show
{
  my($l) = @_;

  #if ($l =~ /^(=+)([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]+):/)
  if ($l =~ /^(=+)(.*)$/)
    {
      my $levstr;
      my $lev;
      my @flds;

      $levstr = $1;
      @flds = split(':', $2);
      $lev = ($levstr =~ tr/=/=/) - 2;

      # Check if this is a real person
      # - If fake: we don't include it...
      if ($flds[13] eq "F") { return; }

      if ($Full)            { print "$l"; }
      elsif (! $UseOptions) { print "$flds[1]\n"; }
      else
      {
         if ($displayoptions =~ /level/) { print "    " x $lev; }

         # Give them at least a login if no login or name param passed
         if ($displayoptions !~ /login|unix|name|fullname/)
         { $displayoptions = "login," . $displayoptions; }

         if ($displayoptions eq "level") { print $flds[1]; }
         else
         {
            foreach my $o (split(/,/,$displayoptions))
            {
               if ($o =~ /^(name|fullname)$/)         { &output (30, $flds[0]); }
               elsif ($o =~ /^(login|unix)$/)         { &output (8,  $flds[1]); }
               elsif ($o =~ /^(loc|location|room)$/)  { &output (15, $flds[4]); }
               elsif ($o =~ /^(phone|tele)$/)         { &output (15, $flds[3]); }
               elsif ($o eq "title")                  { &output (15, $flds[5]); }
               elsif ($o eq "empno")                  { &output (5,  $flds[8]); }
               elsif ($o eq "mgmtchain")              { &output (50,  $flds[18]); }
               elsif ($o eq "email")                  { &output (35, $flds[9]); }
               elsif ($o eq "hire")                   { &output (15, $flds[12]); }
               elsif ($o eq "dept")                   { &output (25, $flds[14]); }
	         }
         }
         print "\n";
      }
    }
}

