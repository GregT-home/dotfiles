#! /bin/sh
#
# keyword-dump
#
# script to notify a specified user that there are BURTs matching 
# the specified search that have a specified keyword set.
#
USAGE='Usage: keyword-dump <addr> key1 key2...
<addr> is the e-mail address to which to send the report, if there are
       matching BURTs.

<keyX> are the keys (at least one is required) to search for

       flags:
         -d[ebug]   Display debugging info and put output on stdout instead
		    of e-mailing to <addr>
	 -m[gr] unixname
                    Scan BURTs whose mgr_owner is <unixname>     
'
# Modification History
# ~~~~~~~~~~~~~~~~~~~~
# 05	Mar 2008, Greg Tarsa
#	Fixed bug in "no output" code.
#	Sorted results by release target to group similar BURTs together 
#	for easier viewing.
#
# 04	Jul-2007, Greg Tarsa
#	Removed "&fz=934" from BURT string as extraneous.  Less chance of
#	line wrapping now.
#
# 03	Jun-2007, Greg Tarsa
#	switched to explicitly using burturborep (instead of "burt report"
#	and added -xdays to the cmd line to show days_new as an age.
#
# 02	Mar-2007, Greg Tarsa
#	added ability to override manager default
#
# 01	Feb-2007, Greg Tarsa
#	Munged from public-dump
#

# ensure that burt cmd can be found in cron runs
PATH="$PATH"":/usr/local/bin:/usr/ucb"
export PATH

mgr_name=`whoami`	# get manager's default unixname
debugflag=""
addr=""
xtraburts=""
nl="
"
keywords=""
kwlist=""

# process switches
while :
do
    # No more arguments?  Move on.
    case $# in
       0) break ;;
    esac

    # process the switches
    case $1 in
       # debug mode?
       -debug|-d*) debugflag=yes ;;

       # override manager default?
       -mgr|-manager|-m*)
	    shift
	    case $# in
	       0) echo 1>&2 "?no manager name specified${nl}$USAGE"
	           exit 1
		   ;;
	    esac
	    mgr_name=$1
	    ;;

       # not a recognized switch string...
       -*) echo 1>&2 "?Invalid switch: $1$nl$USAGE"; exit 1 ;;
       
       # not a switch? Then move on...
       *) break ;;
    esac

    shift # get next word to process
done

# process argument(s)
# get address
case $# in
  0) echo 1>&2 "?No e-mail address specified$nl$USAGE"; exit 1 ;;
  *) addr=$1; shift;;
esac

# check for null, there should be at least one arg in the line
case $# in
  0) echo 1>&2 "?No keyword value(s) specified$nl$USAGE"; exit 1 ;;
esac

while :
do
    # No more arguments? All done
    case $# in
       0) break ;;
    esac

    # unfortunately "echo" converts \b to backspace;
    # need to post-process to get the token back for burt
    keywords="$keywords|\ b($1)\ b"
    kwlist="$kwlist $1"

    shift # get next word to process
done

#remove leading "or" & restore "\b" keyword from echo munge
# note "the "\b" will show up in debug statements as ^H--just live with it
keywords=`echo $keywords | sed 's/^|//; s=\\ b=\\b=g'`
kwlist=`echo $kwlist | sed 's/^ //`

# define the tmp file and setup the trap to cleanup at script completion
tmpfile=/tmp/publicdump$$
trap 'rm -f $tmpfile' 0 INT KILL

# BURT search = BURTs w/ specified keyword for people not reporting to me
#burt_scope='$keywords =~ /'$keywords'/ && $mgr_owner !~ /'"$mgr_name"'/'
burt_scope='($keywords =~ /'$keywords'/ && ($mgr_owner !~ /'"$mgr_name"'/ && $owner !~ /'"$mgr_name"'/ ))'
subject="Action needed: mis-owned BURTs w/ keyword=$kwlist"
burt_area='$type =~ /SW|SW+NG/'
# only search active BURTs
burt_area_exclude='($state =~ /NEW|OPEN|STUDY/ || ($state=~/MULTISTATE/ && $rel_state =~ /NEW|OPEN|STUDY/))'

# combine BURT search criteria into a single spec string (straight concatenate doesn't 
# work if any criteria are null, so only put && for non-null criteria)
#
# i.e.: burt_scope && burt_area && burt_area_exclude
#
burtspec="$burt_scope"
for crit in "$burt_area" "$burt_area_exclude"
do
    case $crit in
      "" ) continue ;;
      *) burtspec="$burtspec && $crit" ;;
    esac
done

# display debug info
case $debugflag
in
   y*)
       echo "${nl}addr=$addr"
       echo "${nl}burtspec=$burtspec" 
       echo "${nl}keywords=$keywords" 
       echo "${nl}kwlist=$kwlist"
       echo "${nl}"
       set -x
       ;;
esac

# list out the qualified BURTs
# hack to change "days new" to something useful when it is truncated.
burturborep -xdays \
     -q"($burtspec)" \
     -f':id sev pri public state:5 rel_state owner:8 subtype:8 target_release:11 title date_new:4 cnt_call_rec' \
     -s'-call_rec target_release public subtype id state pri sev' |
	sed 's%^ *[1-9][0-9]*% http://burtweb.eng.netapp.com:8080/burt-bin/start?id=&\&btn=edit\  &%;s/days+/dysnew/' > $tmpfile

#      -f':id state: sev pri public subtype owner call_rec title' \

#munge the count to remove the wc-inflicted filename
burtcount=`wc -l $tmpfile | fmt -w 1 | head -1| sed 's/ //g'`
set +x

case $burtcount in
    # 1 line means "no records found"; fyi, 1st BURT = 2, 1 for titles, 1 for BURT
    1) exit 0 ;;
esac

#decrement to remove title from the count; add count to subject
burtcount=`expr $burtcount - 1`
subject="$subject (total=$burtcount)"

# double space the BURT report,
# filter the output for prettiness and either e-mail or
# display as debug output
#
# Note: this takes advantage of a side-effect of the fmt cmd.  The long BURT
# link will not be broken by fmt unless it contains a blank, which it
# currently doesn't.  So we know if we use sed to expand the BURT number into
# the http link & the BURT number and separate them by two spaces, fmt
# will break the line at the first space and align the link with the
# BURT data.
#
sed G < $tmpfile | 
	sed 's/|title//' |
	sed 's/|/\
    |/' |
	fmt -72 |
	    case $debugflag in
		# mail the filtered report...
		"") mailx -s "$subject" $addr
		    ;;

		#...or display it on stdout
		 *)
		    echo "The following would be sent to $addr"":"
		    echo "Subject: $subject"
		    cat
		    ;;
	    esac
exit 0


